\documentclass[14pt,a4paper,notitlepage]{extarticle}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{lipsum}
\usepackage{url}

\usepackage{noto}
\usepackage[margin=0.5in]{geometry}

\usepackage{listings}
\lstset{
    tabsize=2,
    basicstyle = \ttfamily\small,
    columns=fullflexible
}

\author{Azullia / 0xFC963F18DC21}
\title{\textbf{\huge{Cracking Open Gran Turismo 4 Spec II's Randomizer}}}

\begin{document}
    \maketitle

    \begin{abstract}
        Gran Turismo 4 Spec II is a modification for the NTSC-U release of Gran Turismo 4's
        Online Public Beta. One of its main defining features is a toggleable prize car
        randomizer, which randomizes what cars one receives as prizes for various actions,
        picked based on one's in-game username. We will discuss the inner workings of Gran
        Turismo 4's internal PRNG, and how it is used by Gran Turismo 4 Spec II to generate
        random prize cars.
    \end{abstract}

    \section*{Preface}
        Gran Turismo 4 Spec II is an ISO patch modification for the US soft-release of
        Gran Turismo 4's Online Public Beta created by TheAdmiester. It brings a lot of
        additions and changes to the main game, but one of its main draws / features is
        its prize car randomizer.

        Debuting in 2023 as the initial public Randomizer build, the feature was brought into
        Spec II as a toggleable option. Both versions share the same apparent functionality:
        changing any prize car\footnote{Prize cars are awarded by Gran Turismo 4 typically for
        completing all tests in a License grade with Bronze, Silver or Gold level times,
        winning all races in a single-race event, winning the overall championship of a
        championship events, completing sets of Driving Missions, etc..} into a
        randomly-selected option based on one's in-game username and the circumstances that one
        is winning a car in.

        As with a lot of other randomizer-adjacent modifications for games, of course, there
        will be people who wish to know how it internally works, so as to:

        \begin{itemize}
            \item Find an optimal seed to route through.
            \item Have a really fun or overpowered seed to play through.
            \item Have an intentionally bad seed as a challenge.
        \end{itemize}

        \noindent And many more possible reasons. As a disclaimer however, the method described
        within this paper does not work with the original public Randomizer build from 2023.

    \section*{Pseudorandom Number Generators (PRNGs)}
        With most if not all kinds of ``randomness'' that occurs in computer programs, they are
        never \textit{truly} random, as that is antithetical to how computers work (i.e. by
        following instructions in a sequence). Without external inputs of data\footnote{
        Cloudflare does something cool for their secure random number generators
        involving some lava lamps (
        \url{https://www.cloudflare.com/en-gb/learning/ssl/lava-lamp-encryption/}),
        for example.}, computers cannot ever truly replicate something that is truly and
        irrefutably random\footnote{By \textit{truly} random, this means that any output is
        completely unaffected by any surrounding state or previous and future inputs or
        outputs.}.

        Keeping that in mind, most if not all programs use \textit{
        Pseudorandom Number Generators}. As their name suggests, they merely ``fake'' or
        ``mimic'' true randomness, and are not actually truly random. Typically, these take
        the form of functions of the form:

        \begin{equation*}
            \text{PRNG}(\text{state}) := (\text{pseudorandom output}, \text{new state})
        \end{equation*}

        Random numbers are generated by repeatedly inputting the new state\footnote{
        The \textit{state} of a PRNG can be as simple or as complex as it needs to be.} as
        the next inputs to the PRNG algorithm. The pseudorandom output can then be used in
        any way the programmer sees fit in order to generate ``random''-looking values.

        \subsection*{Gran Turismo 4's PRNG Algorithm}
            Gran Turismo 4's main exposed interface for pseudorandom number generation is
            \texttt{MRandom}. This is a class exposed in Adhoc\footnote{Adhoc is a scripting
            language used by Polyphony Digital for certain tasks in Gran Turismo 4 onwards.
            See \url{https://nenkai.github.io/gt-modding-hub/concepts/adhoc/adhoc/} for more 
            information.} that is used in all places where Gran Turismo 4 requires
            random-looking values\footnote{The used car dealer uses \texttt{MRandom}, for
            example, to generate the mileages based on the used car cycle week number and car
            index.}.

        \subsection*{\texttt{MRandom}}
            \texttt{MRandom} tracks a simple state: a single unsigned 32-bit integer (which
            represents a whole number between 0 and 4294967295 inclusive). This state is then
            fed into its PRNG function inside, which outputs and stores a new state, along
            with a value that is the ``random-looking'' value generated alongside. It performs
            this using a small portion of code inspired by the CRC32 algorithm.

            \subsubsection*{CRC32}
                The CRC32 algorithm is a checksumming function. Its job is to take a piece of
                data, and perform some operations to mix groups of bytes in the data together
                in the order the data comes in. Normally, it can be used as a form of file
                integrity check (i.e. checking if a file is undamaged / unmodified), but the
                same property that makes it effective for doing so\footnote{A large cascade
                effect, where a small change in input makes a large change in output.} also
                allows it to be a very simple PRNG algorithm.

            \subsubsection*{So how does \texttt{MRandom} work?}
                Essentially, \texttt{MRandom}'s PRNG function looks like the following:

                \begin{lstlisting}
  def mRandomNext(seed: UInt32): (UInt32, UInt32) = {
    var temp: UInt32   = (17 * seed) + 17
    var result: UInt32 = 0

    for (_ in 0 until 4) {
      val index: UInt8 = result ^ temp
      temp = temp >> 8

      result = (result >> 8) ^ CRC32TABLE(index)
    }

    return (result, (17 * seed) + 17)
  }
                \end{lstlisting}

                It simply operates on 8 bits of the 32-bit integer at a time, calculating a
                lookup index (that wraps around 0 through 255), that points to a value in
                a precalculated CRC32 lookup table of values\footnote{The first table in
                \url{https://web.mit.edu/freebsd/head/sys/libkern/crc32.c}}, both using the
                Exclusive Or\footnote{\url{https://en.wikipedia.org/wiki/Exclusive_or}}
                operation.

                Although, this doesn't explain how we get useable numbers within a range
                from these generated pseudorandom values, since without any extra operations,
                we are stuck with a number anywhere between 0 and 4294967295. This is where the
                next two functions come in.

            \subsection*{\texttt{GetRange} and \texttt{RandomInt32ToFloat}}
                \texttt{GetRange} wraps around the raw PRNG function to allow it to generate
                random whole numbers within a range.

                \begin{lstlisting}
  def getRange(incMin: Int32, excMax: Int32, seed: UInt32): Int32 = {
    val (rval, _)  = mRandomNext(seed)
    val multiplier = randomInt32ToFloat(rval)

    // The decimal of the result of the multiplication is chopped off.
    return ((excMax - incMin) * multiplier + incMin)
  }
                \end{lstlisting}

                \noindent \texttt{RandomInt32ToFloat} translates an unsigned 32-bit integer
                into a decimal value between 0 and 1, where each number between 0 and 4294967295
                is translated evenly into that range (with the caveat that 1 is never returned,
                hence the maximum given in \texttt{GetRange} is exclusive).

    \section*{Spec II Prize Car Randomizer}
        In Gran Turismo 4 Spec II, if the prize car randomizer is enabled, when one would
        normally earn a prize, instead of awarding the prize associated with that instance of
        a prize, it will randomly select a car from a list of all cars available in Spec II.

        How it randomly selects a car is based on the username, the current event that is
        giving the prize car, and what type of trigger it is:

        \begin{itemize}
            \item Username is self-explanatory. It is the up to 30-long string one inputs when
            making a save on a memory card for the first time\footnote{If entering usernames
            there, \textbf{do not} use the HD HUD / UI texture pack, as that incorrectly blanks
            out some of the keys on the improved keyboard.}.
            \item Events are a list labels of events that you can win a prize car in, they
            represent things like event hall events (Sunday Cup, etc.), License grade tiers (B
            Bronze, etc.) or Mission Set completions (e.g. One-Lap Magic 30-34).
            \item Types of triggers denote what kind of condition it was activated (an event
            win, mission set completion, license grade completion, etc.).
        \end{itemize}

        \noindent These parts are then put together into one big string, and that is then used
        as the seed whenever one wins a prize (e.g. Username ``Foo'', event Sunday Cup
        (``am\_sunday\_0000'') and type ``win'' is put together to become
        \\``Fooam\_sunday\_0000win''). The question is then:

        \begin{center}
            How does it turn that text into a number to feed into \texttt{GetRange}?
        \end{center}

        \subsection*{Fowler-Noll-Vo Hashes}
            A hash function is a way to generate a ``summary'' of a piece of data, similar to
            a checksum. They also ideally exhibit the same property as a checksum, where a
            small change in input data creates a massive change in the final hash output.

            Gran Turismo 4 Spec II uses a variant of the Fowler-Noll-Vo algorithm, a very simple
            to implement hashing algorithm, especially for text / strings. Its implementation
            in Spec II is specifically the FNV-1a variant, which looks like:
            \pagebreak
            \begin{lstlisting}
  def fnv1a(str: String): UInt32 = {
    // These starting values can usually be substituted for other
    // suitable values in other implementations of FNV-1a.
    val prime: UInt32  = 16777619
    var result: UInt32 = 0x811C9DC5

    for (chr in str) {
      result ^= chr.toUInt8
      result *= prime
    }

    return result
  }
            \end{lstlisting}

            \noindent So the example string such as ``Fooam\_sunday\_0000win'' is then passed
            into \texttt{fnv1a} (which in this case becomes 3244945079), and then the result is
            passed into \texttt{GetRange} as the seed.

        \subsection*{Final Algorithm}
            Putting it all together, we have the following algorithm:

            \begin{lstlisting}
  extern val allCars: List[Car]

  def randomPrize(username: String, event: String, trig: String): Car = {
    val seed  = fnv1a(username + event + trig)
    val index = getRange(0, allCars.length, seed)

    return allCars(index)
  }
            \end{lstlisting}

            \noindent A very simple algorithm overall, but very effective at its objective of
            delivering the player random prize cars based on username\footnote{For cars with
            multiple possible colours, the seed fed to \texttt{GetRange} is based on the PS2's
            system clock.}, while being able to choose the same car again should a player
            decide to (e.g.) repeat an event they've won a prize car before.

    \section*{Appendices}
        \subsection*{Spec II Adhoc Sources}
            They can be found on TheAdmiester's GitHub here:
            \url{https://github.com/TheAdmiester/OpenAdhoc-GT4SpecII}.

            Please be warned that programming knowledge is needed to
            understand the code, and a primer can be found on Nenkai's GT Modding hub at
            \url{https://nenkai.github.io/gt-modding-hub/concepts/adhoc/adhoc/}

        \subsection*{Analyzer Tool Sources}
            They can be found at \url{https://github.com/MF42-DZH/GT4S2RC}.

        \subsection*{Seed Bruteforcing}
            With the possibility to now check the cars found in a seed for Spec II's
            Randomizer, it becomes possible to look though seeds (many, many seeds) in order
            to try and find a seed optimised for some purpose.

            TeaKanji was and is a major help in this process, providing both approximate
            ``viability'' values for all cars in Spec II, and a list of cars that are essential
            for a 100\% run using just prize cars supplied by the randomizer. We've both gone
            through likely millions of usernames, checking their prizes to see if we can either:

            \begin{itemize}
                \item Find a seed with consistently overpowered car drops.
                \item Find a seed where it is possible to 100\% the game in with just prize cars.
            \end{itemize}

            The first goal was achieved relatively comfortably by trying to find seeds with
            a high average car viability, some examples include:

            \begin{itemize}
                \item \texttt{GatewomanBoundaries} (with its \textbf{five} 787Bs!)
                \item \texttt{ZaniestDisconcert} (with its \textbf{B License Bronze}\\Formula
                Gran Turismo!)
                \item \textbf{[REDACTED AT THE REQUEST\footnote{(at gunpoint)} OF CERO, PEGI,
                THE ACB, AND THE ESRB]}
                \item \texttt{std::reinterpret\_cast<float>} (with its \textbf{five} BMW V12
                LMRs!)
            \end{itemize}

            The closest we have gotten to a username that can 100\% the game with only prize cars
            from the randomizer has four cars needing to be bought for a candidate seed, one such
            example being ``AcritanRawest'' (case-sensitive).

            \subsubsection*{The 100\% Impossibility (as of 2024-11-10)}
                It turns out that there is no username out of the many, \textit{many} possible
                usernames\footnote{There are $93^{30} + 93^{29} + \dots + 93^1$ possible usernames}
                that can complete the game to 100\% completion with just randomized prize
                cars. This property can be found by exploiting the implementation of the randomizer.
                Recall FNV-1a's implementation:

                \begin{lstlisting}
  def fnv1a(str: String): UInt32 = {
    // These starting values can usually be substituted for other
    // suitable values in other implementations of FNV-1a.
    val prime: UInt32  = 16777619
    var result: UInt32 = 0x811C9DC5

    for (chr in str) {
      result ^= chr.toUInt8
      result *= prime
    }

    return result
  }
                \end{lstlisting}

                There are only $2^{32}$ possible hashes that can be output from this function and
                used as a seed for \texttt{MRandom::GetRange} for selecting cars. If one
                looks at the algorithm's definition, the \texttt{result} variable has no
                post-processing being applied to it after the main hasing loop finishes.
                This means one can derive the following property: the FNV-1a hash of any arbitrary
                string is equal to the hash of its immediate prefix, XOR-ed by the character code
                of the remaining character, then multiplied by 16777619 (modulo $2^{32}$), formally:
                \begin{align*}
                    \forall s \in \text{Non-Empty Strings}\ .\ s &\equiv \text{All-But-Last Character} \diamond \text{Last Character}\\
                    \implies s &\equiv \text{init} \diamond \text{last}\\
                    \implies \text{\texttt{FNV-1a}}(s) &\equiv (\text{\texttt{FNV-1a}}(\text{init})\ \oplus\ \text{last}) \times 16777619 \mod 2^{32}
                \end{align*}

                One could then see that this can be applied inductively, where you can take successive
                prefixes of a target string to hash under FNV-1a to ``precalculate'', so to speak.
                Given a modified version of FNV-1a that looks as follows:

                \begin{lstlisting}
  def fnv1aSuffix(initialValue: UInt32, stringSuffix: String): UInt32 = {
    // These starting values can usually be substituted for other
    // suitable values in other implementations of FNV-1a.
    val prime: UInt32  = 16777619
    var result: UInt32 = initialValue

    for (chr in str) {
      result ^= chr.toUInt8
      result *= prime
    }

    return result
  }
                \end{lstlisting}

                We can then effectively use this property along with our modified FNV-1a to factor out
                the username's hash to be a ``precalculated value'' that we then hash along with the
                concatenated event label and trigger types to generate the prize car list for a
                particular username hash\footnote{There are many more usernames than hashes, so some
                different usernames will hash into the same value}, using something like the
                following to test a single event's prize for a username hash and then applying it to
                all prizes and all hashes:

            \begin{lstlisting}
  extern val allCars: List[Car]

  def randomPrizeHash(hash: UInt32, event: String, trig: String): Car = {
    val seed  = fnv1aSuffix(usernameHash, event + trig)
    val index = getRange(0, allCars.length, seed)

    return allCars(index)
  }
            \end{lstlisting}

                Out of the possible $2^{32}$ hashes / prize lists of cars, the following statistics
                were observed after bruteforcing the data for all those hashes:

                \begin{itemize}
                    \item 230 hashes result in a prize lineup missing 5 cars for a 100\% playthrough.
                          There are too many to list here.
                    \item 17 hashes result in a prize lineup missing 4 cars for a 100\% playthrough.
                    \begin{itemize}
                        \item 585265398, 634454505, 1309767868, 1369703188, 1392599962,\\1432721073, 1520546429, 1912668018, 2103087292, 2258225527,\\2641602117, 2714909022, 2776772991, 3019592698, 3289153551,\\3634232672, 3981126976
                    \end{itemize}
                \end{itemize}

                No possible username hash generate a prize car list with three, two, one,
                or even zero cars missing for a 100\% playthrough with random prize cars only
                as of Spec II v1.07.

            \subsubsection*{Reversing the FNV-1a Hash}
                The simple implementation of the FNV-1a hash also lets us perform a brute-force hash
                reversal for short inputs. It is impossible to, with 100\% certainty, obtain the exact
                input string used to generate a hash, but we can at least make do with having a result
                string that hashes back into the hash we wanted to brute-force.

                We simply need to run its steps in reverse:

                \begin{enumerate}
                    \item Reverse its multiplication by 16777619 under modulo $2^{32}$.
                    \item XOR our result from Step 1 by the numeric value of a character.
                \end{enumerate}

                Repeating these steps for every character we want to prepend to the
                username being constructed, until we reach back to the original offset
                of the algorithm of \texttt{0x811c9dc5}.
                XOR is thankfully its own inverse, but
                inverting a multiplication under modulo is a little more complex.
                We will essentially need to find a number $\mathbf{In}$ such that:
                \begin{align*}
                    16777619x &\equiv x' \mod 2^{32}\\
                    \mathbf{In} \cdot x' &\equiv x \mod 2^{32}
                \end{align*}

                Or more formally, find the \textit{modular multiplicative inverse} of
                16777619 under modulo $2^{32}$. There thankfully is an optimized solution
                to this, taking into account that 16777619 and $2^{32}$ are co-prime
                (the only number that can divide both of them with no remainder is 1).

                The fact that they are co-prime means that we do have such an inverse
                that we can calculate, via use of the \textbf{Extended Euclidean Algorithm},
                which we can use to connect 16777619, our mystery number \textbf{In}, and
                their greatest common divisor (1, since they're co-prime):
                \begin{align*}
                    16777619 \cdot \mathbf{In} + 2^{32} \cdot y &= 1\\
                    16777619 \cdot \mathbf{In} + 2^{32} \cdot y &\equiv 1 \mod 2^{32}\\
                    16777619 \cdot \mathbf{In} &\equiv 1 \mod 2^{32}\ \text{(Multiples of our modulus decay to 0.)}
                \end{align*}

                The Extended Euclidean Algorithm (EEA) takes in two integers, $a$ and $b$, and return
                another two integers, $x$ and $y$, that satisfy the following identity:

                \begin{equation*}
                    ax + by = \text{gcd}(a, b)
                \end{equation*}

                We have already seen that because our two numbers are co-prime, we have a
                greatest common divisor of 1. If one squints long enough, you can see that
                \textbf{In} fits where $x$ is in that identity, so the EEA can be used here to
                find our inverse. The EEA can be defined recursively as follows:

                \begin{equation*}
                    \text{EEA}(a, b) \triangleq \begin{cases}
                        (1, 0) & b = 0\\
                        \begin{array}{rrcl}
                            \text{\textbf{Let }} & q & = & a\ \text{div}\ b \\
                            & r & = & a\ \text{mod}\ b \\
                            & (u, v) & = & \text{EEA}(b, r) \\
                            \text{\textbf{In }} & & & (v, u - (q \times v))
                        \end{array} & \text{otherwise}
                    \end{cases}
                \end{equation*}

                Evaluating $\text{EEA}(16777619, 2^{32})$ gives $(899433627,-3513497)$.
                This means our modular multiplicative inverse (\textbf{In}) is $899433627$, finally
                satisfying our equation from before:
                \begin{align*}
                    16777619x &\equiv x' \mod 2^{32}\\
                    899433627 x' &\equiv x \mod 2^{32}
                \end{align*}

                \noindent Taking all of that together, we can derive a way to brute-force a username
                that is hashed into a desired input.
                \pagebreak
                \begin{lstlisting}
  // Consult S2RA/Bruteforce.hs to see the character set.
  extern charset: String

  type Intermediate = (String, Int, UInt32)

  def reverseHash(hash: UInt32, maxLength: Int = 30): Option[String] = {
    val potentials: Queue[Intermediate] = new Queue[Intermediate]()
    potentials.enqueue(("", 0, hash))

    while (potentials.nonEmpty) {
      val (soFar, len, chs) = potentials.dequeue()
      val prepended = charset.map { c =>
        (c +: soFar, len + 1, (899433627 * chs) ^ c.toUInt8)
      }

      prepended.find { case (_, _, h) => h == 0x811c9dc5 } match {
        case Some((n, _, _)) => return Some(n)
        case None => prepended.foreach(potentials.enqueue)
      }
    }

    return None
  }
                \end{lstlisting}

                \noindent There is the caveat that this algorithm is very memory inefficient, and
                is extremely slow. There may not also be a username returned, since the character
                set typeable into Spec II's username input keyboard is limited.

        \subsection*{Acknowledgements}
            \small{
                \begin{itemize}
                    \item \textbf{Nenkai}: Disassembly Help and GTHD Debug Executables Archive
                    \item \textbf{TeaKanji}: Car Viability Info, 100\% Necessities Info,
                    Bruteforcing Script Help
                    \item \textbf{clienthax}: The \texttt{PS3GhidraScripts} package for Ghidra
                    \item \textbf{beardypig, astrelsky}: The \texttt{ghidra-emotionengine} scripts
                    for Ghidra
                    \item \textbf{mrxbas, Yellowbird}: General Support
                    \item \textbf{TheAdmiester}: Creating Gran Turismo 4 Spec II
                \end{itemize}
            }
\end{document}
